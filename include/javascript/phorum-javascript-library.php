////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//   THIS IS THE PHORUM JAVASCRIPT LIBRARY.                                   //
//   DO NOT EDIT THIS FILE DIRECTLY! IT WAS COMPILED FROM THE SOURCES         //
//   THAT CAN BE FOUND UNDER THE 'include/javascript/src' SUBDIRECTORY.       //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//   Copyright (C) 2016  Phorum Development Team                              //
//   http://www.phorum.org                                                    //
//                                                                            //
//   This program is free software. You can redistribute it and/or modify     //
//   it under the terms of either the current Phorum License (viewable at     //
//   phorum.org) or the Phorum License that was distributed with this file    //
//                                                                            //
//   This program is distributed in the hope that it will be useful,          //
//   but WITHOUT ANY WARRANTY, without even the implied warranty of           //
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.                     //
//                                                                            //
//   You should have received a copy of the Phorum License                    //
//   along with this program.                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

/**
 * @class Phorum
 * @extends Object
 *
 * The Phorum singleton acts as the top level namespace for all Phorum
 * JavaScript code. Methods, objects and classes are stored in this
 * object. This takes away the risk of running into name space collissions
 * with other JavaScript code.
 *
 * @singleton
 */
var Phorum = {

    /**
     * @property library_version
     *
     * <p>
     *   The version of this library.
     * </p>
     * <p>
     *   This can be used by other code to check if the correct version of
     *   the library is loaded. The library_version object contains
     *   two properties:
     *   <div class="mdetail-params"><ul>
     *     <li><b>major:</b> major version, incremented when
     *         backward compatibility is broken</li>
     *     <li><b>minor:</b> minor version, incremented when
     *         new functionality is implemented</li>
     *   </ul></div>
     * </p>
     *
     * @var Object
     */
    library_version: {
        major: 1,
        minor: 1
    },

    /**
     * @property debuglevel
     *
     * Configures the debug level for {@link #debug Phorum.debug()}.
     * Set this variable to a higher number for more debugging information.
     * A value of 0 (zero) will suppress all debug output.
     *
     * @var Integer
     */
    debuglevel: 0,

    /**
     * @property http_path
     *
     * The base URL for the forum. JavaScript code can use this URL to build
     * URLs for this forum.
     *
     * @var String
     */
    http_path: '<?php print phorum_api_url_base() ?>'
};
/**
 * @class Phorum.jQuery
 *
 * <p>
 *   The jQuery object for the jQuery library that Phorum loads is
 *   stored in Phorum.jQuery.
 * </p>
 * <p>
 *   A short length reference to the jQuery object is additionally stored
 *   in the global variable <b>$PJ</b> instead of the default <b>$</b>
 *   jQuery variable.
 * </p>
 * <p>
 *   This is a no-conflict jQuery reference for use by Phorum code
 *   (see the jQuery documentation for jQuery.noConflict()).
 *   By using a no-conflict library, our jQuery library will not conflict
 *   with existing javascript libraries (e.g. when Phorum is embedded in
 *   another application that uses a javascript library or when a module is
 *   loaded that also loads a javascript library of its own).
 * </p>
 * <p>
 *   If you want to use the regular <b>$</b> jQuery reference in your
 *   functions, then you could use a construction like this:
 * </p>
 * <p><pre><code>
function yourfunction() {
  var $ = Phorum.jQuery;
  ...
  ...
}
 * </code></pre></p>
 *
 * @singleton
 */
var $PJ = Phorum.jQuery = jQuery.noConflict();

/**
 * <p>
 *   Uses the console.debug() method (originally introduced by the Firebug
 *   plugin for Firefox) for logging debugging information.
 *   When no console is available, then no logging is done at all.
 * </p>
 * <p><pre><code>
Phorum.debuglevel = 10;

Phorum.debug('Hello, world!', 5); // <-- this will output the debug message
Phorum.debug('Bye, world!', 11);  // <-- silent, Phorum.debuglevel is too low
 * </code></pre></p>
 *
 * @param {String} message
 *     The message to write to the debug log.
 *
 * @param {Integer} level (optional)
 *     The debug level of the message. Only messages that have a
 *     debugging level equal to or below the configuration variable
 *     {@link #debuglevel Phorum.debuglevel} are logged.
 *     If no debug level is provided, then level = 1 is implied.
 *
 * @param {mixed} data (optional)
 *     Optional argument containing a variable which' contents should be
 *     logged. The data will be written to the debug log as a JSON structure.
 *
 * @member Phorum debug
 */
Phorum.debug = function (message, level, data)
{
    level = parseInt(level, 10);
    if (isNaN(level)) {
        level = 1;
    }
    if (level < 0) {
        level = 1;
    }

    if (Phorum.debuglevel && Phorum.debuglevel >= level &&
        console !== undefined && console.debug instanceof Function)
    {
        if (data !== undefined) {
            data = ': ' + JSON.stringify(data);
        } else {
            data = '';
        }

        console.debug('Phorum debug [' + level + '] ' + message + data);
    }
};

/**
 * A class extension system. Example usage:
 *
 * <p><pre><code>
// Constructor for Parent:
var Parent = Phorum.extend(function (args) {
    // Constructor code
    ...
}, {
    // Properties and methods to add to the prototype of Parent.
    prop: 'parent property',
    func: function () { alert('cool'); }
    ...
});

// Constructor for Child, extending on Parent and applying
// extra prototype properties for the Child:
var Child = Phorum.extend(Parent, function (args) {
    // Constructor code
    this.parentConstructor(args); // <-- this one must be called
    ...
}, {
    childprop: 'child property',
    childfunc: function () { alert('nice'); }
});
 * </code></pre></p>
 *
 * @param {Function} base
 *   The base constructor.
 *
 * @param {Object/Function} extension
 *   When this argument is an object, then all properties from the
 *   object will be applied to the prototype of the base constructor.
 *   When this argument is a function, then that function will be
 *   setup as a child for the base constructor.
 *
 * @param {Object} child_prototype (optional)
 *   When extending a child class, then this third parameter can be
 *   used to directly provide an object which' properties will be
 *   applied to the prototype of the child class.
 *
 * @member Phorum extend
 */
Phorum.extend = function (base, extension, child_prototype)
{
    var p;

    if (extension instanceof Function)
    {
        extension.prototype.parentConstructor = base;

        for (p in base.prototype) {
            if (true) { // keep jslint happy
                extension.prototype[p] = base.prototype[p];
            }
        }

        if (child_prototype) {
            for (p in child_prototype) {
                if (true) { // keep jslint happy
                    extension.prototype[p] = child_prototype[p];
                }
            }
        }

        return extension;
    }
    else
    {
        for (p in extension) {
            if (true) { // keep jslint happy
                base.prototype[p] = extension[p];
            }
        }
        return base;
    }
};

/**
 * Trim whitespace from the start and end of a string.
 *
 * <p><pre><code>
var a = "\t\n\t  string with mad whitespace \t\t\n\n\n  ";
var b = Phorum.trim(a);
>>> b now contains "string with mad whitespace"

var c = Phorum.trim(a, true);
>>> c[0] contains "string with mad whitespace"
>>> c[1] contains "\t\n\t  "
>>> c[2] contains "\t\t\n\n\n  "

 * </code></pre></p>
 *
 * @param {String} str
 *   The string from which to trim the surrounding whitespace.
 * @param {Boolean} return_trimmed (optional)
 *   If true, then this method will return three values in an array:
 *   the trimmed string, the whispace that was trimmed from the
 *   left and the whitespace that was trimmed from the right.
 *   If false (the default), then only the trimmed string will
 *   be returned.
 * @return {mixed} result
 *   Either an array or a string is returned, depending on the
 *   return_trimmed parameter.
 *
 * @member Phorum trim
 */
Phorum.trim = function (str, return_trimmed)
{
    var trim_pre = '';
    var trim_post = '';

    // Trim whitespace from end of string.
    for (;;) {
        var lastchar = str.substring(str.length - 1, str.length);
        if (lastchar === ' '  || lastchar === '\r' ||
            lastchar === '\n' || lastchar === '\t') {
            trim_post = lastchar + trim_post;

            str = str.substring(0, str.length - 1);
        } else {
            break;
        }
    }

    // Trim whitespace from start of string.
    for (;;) {
        var firstchar = str.substring(0, 1);
        if (firstchar === ' '  || firstchar === '\r' ||
            firstchar === '\n' || firstchar === '\t') {
            trim_pre += firstchar;
            str = str.substring(1);
        } else {
            break;
        }
    }

    if (return_trimmed) {
        return [ str, trim_pre, trim_post ];
    } else {
        return str;
    }
};
// ----------------------------------------------------------------------
// Ajax communication
// ----------------------------------------------------------------------

/**
 * @class Phorum.Ajax
 * @extends Object
 *
 * The Phorum.Ajax singleton provides tools for handling Phorum Ajax
 * communication. Ajax calls are done to the ajax.php script of the Phorum
 * system, which will handle the call and return the result.
 *
 * @singleton
 */
Phorum.Ajax =
{
    /**
     * @property url
     *
     * The URL that we use to access the Phorum Ajax layer script.
     * Note that the 'callback=?' part in this URL is a special placeholder
     * for jQuery's JSONP implementation (Phorum uses JSONP as the Ajax
     * call method).
     *
     * @var String
     */
    url: '<?php print phorum_api_url(PHORUM_AJAX_URL,"callback=?")?>',

    /**
     * <p>
     *   Execute an Ajax Phorum call.
     * </p>
     * <p>
     *   This method is also available through the alias
     *   {@link Phorum#call Phorum.call()}.
     * </p>
     *
     * @param {Object} req
     *   <p>
     *     The request object. This is object needs at least the property
     *     <b>"call"</b>. This property holds the name of the Ajax call that
     *     must be handled by the ajax.php script on the server.
     *   </p>
     *   <p>
     *     When the <b>"cache_id"</b> property is set, then the Phorum.Cache is
     *     used for caching the call result data. It is the task of the
     *     caller to make sure that the provided cache_id is
     *     <em>globally unique</em>.
     *   </p>
     *   <p>
     *     The <b>"onFailure"</b> property can be set for handling Ajax errors.
     *     Its value should be a function that handles the error that was
     *     returned by the Ajax call. This function will be called with the
     *     error message as its argument.
     *   </p>
     *   <p>
     *     The <b>"onSuccess"</b> property can be set for handling a successful
     *     Ajax call. Its value should be a function that handles the data
     *     that was returned by the Ajax call. This function will be called
     *     with two arguments:
     *     <ul>
     *       <li>the data that was returned by the Ajax call</li>
     *       <li>whether (true) or not (false) the result was returned
     *           from cache</li>
     *     </ul>
     *   </p>
     *   <p>
     *     All other properties will be sent to the ajax.php script as call
     *     arguments. What call arguments are available depends on the
     *     Phorum Ajax call that is called. Check the documentation of
     *     the call for details.
     *   </p>
     *
     *   <b>Example code:</b>
     *   <p><pre><code>
Phorum.Ajax.call({

   call: 'foo',
   arg1: 'bar',
   arg2: 'baz',
   cache_id: 'foo-bar-bar-id',

   onSuccess: function (data, from_cache) {
       alert('Call successful, data loaded ' +
             (from_cache ? ' from cache' : ' from server'));
   },

   onFailure: function (error) {
       alert('Call failed: ' + error);
   }
})
     *   </code></pre></p>
     */
    call: function (req)
    {
        // Check if a call was provided in the request data.
        if (! req.call) {
            Phorum.debug(
                'Phorum.Ajax.call() error: missing property ' +
                '"call" for the request object', 1, req
            );
            if (req.onFailure) {
                req.onFailure(
                    'Phorum.Ajax.call() error: missing property ' +
                    '"call" for the request object.',
                    -1, null
                );
            }
            return;
        }

        // If the req.cache_id property is set for the request, then check
        // if the data for the request is already available in the
        // local cache. If yes, then return the data immediately.
        if (req.cache_id) {
            var data = Phorum.Cache.get(req.cache_id);

            if (data !== null) {
                Phorum.debug(
                    'Phorum.Ajax.call calls onSuccess with cached data ' +
                    'for cache_id "' + req.cache_id + '"', 4, data
                );
                if (req.onSuccess) {
                    // true = data retrieved from cache.
                    req.onSuccess(data, true);
                }
                return;
            }
        }

        // Create a filtered argument list (without functions and control args).
        var args = {};
        for (var key in req) {
            if (typeof req[key] !== 'function' && key !== 'cache_id') {
                // Convert complex arguments to JSON, otherwise they will
                // not survive the translation to a JSONP request URL.
                if (typeof(req[key]) === 'object') {
                    args[key] = '$JSON$' + JSON.stringify(req[key]);
                } else {
                    args[key] = req[key];
                }
            }
        }

        // Notify the start of the request loading stage.
        Phorum.debug('Phorum.Ajax.call calls server with args', 5, args);
        if (req.onRequest) {
            req.onRequest(args);
        }

        $PJ.getJSON(Phorum.Ajax.url, args, function (answer)
        {
            Phorum.debug(
                'Phorum.Ajax.call receives answer from server', 5, answer
            );
            if (typeof answer.error === 'undefined')
            {
                // If the req.cache_id property is set, then cache the results.
                if (req.cache_id) {
                    Phorum.Cache.put(req.cache_id, answer);
                }

                // false = data not retrieved from cache.
                Phorum.debug(
                    'Phorum.Ajax.call calls onSuccess with', 4, answer
                );
                if (req.onSuccess) {
                    req.onSuccess(answer, false);
                }
            }
            else
            {
                Phorum.debug(
                    'Phorum.Ajax.call calls onFailure with', 4, answer.error
                );
                if (req.onFailure) {
                    req.onFailure(answer.error);
                }
            }
        });
    },

    /**
     * <p>
     *   Parse out javascript blocks from the data and eval them.
     * </p>
     * <p>
     *   This can be used to process javascript code that is embedded in
     *   dynamically retrieved blocks of HTML code. Adding this data to
     *   the page (e.g. by using document.write or innerHTML) would not
     *   evaluate the javascript code. Browsers only parse and evaluate
     *   javascript code that is retrieved at page load time.
     * </p>
     *
     * @param {String} data
     *   The data from which to parse the javascript blocks.
     */
    evalJavaScript: function (data)
    {
        var cursor = 0;
        var start  = 1;
        var end    = 1;

        while (cursor < data.length && start > 0 && end > 0) {
            start = data.indexOf('<script', cursor);
            end   = data.indexOf('</script', cursor);
            if (end > start && end > -1) {
                if (start > -1) {
                    var res = data.substring(start, end);
                    start = res.indexOf('>') + 1;
                    res = res.substring(start);
                    if (res.length !== 0) {
                        eval(res);
                    }
                }
                cursor = end + 1;
            }
        }
    }
};

// ----------------------------------------------------------------------
// Caching
// ----------------------------------------------------------------------

/**
 * @class Phorum.Cache
 * @extends Object
 *
 * The Phorum.Cache singleton is a caching layer that can be used by Phorum
 * JavaScript code for handling client side data caching. The cache is a
 * simple key/value pair based data storage. It supports TTLs for automatically
 * expiring cached data.
 *
 * @singleton
 */
Phorum.Cache =
{
    /**
     * @property ttl
     *
     * The default TTL in seconds for cache entries. A value of 0 (zero)
     * can be used to cache the data indefinitely (or until a
     * {@link #purge purge()} is done on the cached data).
     *
     * @type Integer
     */
    ttl: 0,

    /**
     * @property data
     *
     * The cache storage.
     *
     * @type Object
     * @private
     */
    data: {},

    /**
     * Store data in the cache.
     *
     * @param {String} cache_id
     *   This id is used as the key under which to store the data
     *   in the cache. Make sure that you use globally unique cache id's
     *   (e.g. instead of "1234", it is advised to use something like
     *   "myapp-user-1234" to prevent collissions).
     * @param {mixed} data
     *   The data to store in the cache.
     * @param {Integer} ttl (optional)
     *   The TTL (time to live) in seconds for the cached data. If no TTL
     *   is provided or if it is not recognized as a valid number, then the
     *   default {@link #ttl Phorum.Cache.ttl} is used instead.
     */
    put: function (cache_id, data, ttl)
    {
        // Determine the TTL to use for the cache entry.
        if (ttl === undefined) {
            ttl = Phorum.Cache.ttl;
        } else {
            ttl = parseInt(ttl, 10);
            if (ttl === 'NaN') {
                ttl = Phorum.Cache.ttl;
            }
        }

        // Determine the expire time. When ttl = 0, then
        // no expiration is done at all.
        var expire_t = 0;
        if (ttl !== 0) {
            var d = new Date();
            expire_t = d.getTime() + 1000 * ttl;
        }

        // Store the data in the cache.
        Phorum.Cache.data[cache_id] = [data, expire_t];
    },

    /**
     * Retrieve data from the cache.
     *
     * @param {String} cache_id
     *   The key under which to the data was stored in the cache
     *   using {@link #put Phorum.Cache.put()}.
     *
     * @return mixed
     *   In case no cache data was found or the cache data expired,
     *   then null is returned. Otherwise, the cached data is returned.
     */
    get: function (cache_id)
    {
        // Check if there is a cache entry available.
        if (typeof Phorum.Cache.data[cache_id] === 'undefined') {
            Phorum.debug(
                'Phorum cache miss for cache_id "' + cache_id + '"', 5
            );
            return null;
        }
        var c = Phorum.Cache.data[cache_id];

        // TTL set? Then check if the cache entry hasn't expired yet.
        if (c[1] !== 0) {
            var d = new Date();
            var now = d.getTime();
            if (now > c[1]) {
                Phorum.debug(
                    'Phorum cache expired for cache_id "' + cache_id + '"', 5
                );
                return null;
            }
        }

        Phorum.debug('Phorum cache hit for cache_id "' + cache_id + '"', 5);
        return c[0];
    },

    /**
     * Purge a single cached item or the full cache.
     *
     * @param {String} cache_id (optional)
     *   When this parameter is provided, then the cache data for
     *   the cache_id is purged from the cache. Otherwise, the full
     *   cache is purged.
     */
    purge: function (cache_id)
    {
        if (cache_id !== undefined) {
            Phorum.Ajax.cache[cache_id] = null;
        } else {
            Phorum.Ajax.cache = {};
        }
    }
};

// ----------------------------------------------------------------------
// User Interface
// ----------------------------------------------------------------------

/**
 * @class Phorum.UI
 * @extends Object
 *
 * Phorum.UI is a singleton that provides user interface handling methods
 * and acts as the namespace for storing user interface related classes.
 *
 * @singleton
 */
Phorum.UI = { };

/**
 * <p>
 *   Retrieve the width of the scrollbar in the browser.
 * </p>
 * <p>
 *   This implements a reliable way of determining the width
 *   of the scrollbar. One cannot rely on a predefined width,
 *   because this width differs per OS and browser.
 * </p>
 * <p><pre><code>
Phorum.UI.scrollbarwidth();
>>> "15px"
Phorum.UI.scrollbarwidth(true);
>>> 15
 * </code></pre></p>
 *
 * @param {Boolean} as_integer
 *   When true (default is false), then the integer pixel width is
 *   returned (e.g. 10). Otherwise, a formatted CSS width is returned
 *   (e.g. "10px").
 *
 * @return {Integer} width
 *   The width of the scrollbar in pixels.
 *
 * @member Phorum.UI scrollbarwidth
 */
Phorum.UI.scrollbarwidth = function (as_integer)
{
    if (Phorum.UI.scrollbarwidth.width === undefined) {
        var $outer = $PJ('<div/>').css({
            width    : '100px',
            height   : '100px',
            position : 'absolute',
            top      : '-200px',
            left     : '-200px'
        });
        var $inner = $PJ('<div/>').css({
            height   : '100px'
        });
        $outer.append($inner);
        $PJ('body').append($outer);

        var without_scrollbar = $inner.innerWidth();
        $outer.css('overflow-y', 'scroll');
        var with_scrollbar = $inner.innerWidth();
        $outer.remove();

        Phorum.UI.scrollbarwidth.width = (without_scrollbar - with_scrollbar);
    }

    return Phorum.UI.scrollbarwidth.width + (as_integer ? 0 : 'px');
};

/**
 * @class Phorum.UI.Element
 *
 * <p>
 *   This class is a base class that is used for building objects that
 *   can manage page elements.
 * </p>
 *
 * @constructor
 *   Create a new Phorum.UI.Element object.
 * @param {String/Array/jQuery} selector (optional)
 *   This parameter determines the page element to wrap. This is one of:
 *   <div class="mdetail-params"><ul>
 *     <li>A jQuery selector to use for looking up the element. This
 *         must result in exactly one matching element.</li>
 *     <li>An array of jQuery selectors. Each selector is tried in sequence.
 *         The first selector that results in exactly one matching element
 *         will be used. This method allows to match multiple selectors for
 *         backward compatibility.</li>
 *     <li>A jQuery object. This object must contain exactly one element.</li>
 *     <li>When this parameter is omitted, then the selectors from the
 *         {@link #selectors selectors} configuration property will be
 *         used instead.</li>
 *   </ul></div>
 */
Phorum.UI.Element = Phorum.extend(

    // Constructor ==========================================================

    function (selectors)
    {
        // jQuery object.
        if (selectors instanceof Object)
        {
            if (selectors.length !== 1) {
                throw this.className + ' constructor: the selectors ' +
                      'parameter must match exactly one DOM element when ' +
                      'a jQuery object is provided.';
            }

            this.object  = selectors[0];
            this.$object = selectors;
            this.$       = selectors;
            return;
        }

        // jQuery selectors.
        selectors = (selectors === undefined || selectors === null) ?
                    this.selectors :
                    $PJ.isArray(selectors) ? selectors : [ selectors ];

        // Lookup the first selector for which a unique element can be found.
        for (var i = 0; i < selectors.length; i++)
        {
            var selector = selectors[i];

            Phorum.debug(
                this.className + ' constructor: lookup element for "' +
                selector + '"', 10
            );

            var $tmp = $PJ(selector);

            if ($tmp.length === 1) {
                Phorum.debug(
                    this.className + ' constructor: found unique element for ' +
                    '"' + selector + '"', 10
                );
                this.$object = $tmp;
                this.$       = $tmp;
                this.object  = $tmp[0];
                return;
            } else {
                Phorum.debug(
                    this.className + ' constructor: number of elements for ' +
                    '"' + selector + '": ' + $tmp.length, 10
                );
            }
        }

        throw this.className + ' constructor: no object found for ' +
              'selectors: ' + selectors.join(', ');
    },

    // Prototype ============================================================

    {
        /**
         * @property className
         *
         * The name of this class, for easy reference.
         * Derived classes must override this property.
         *
         * @var String
         * @private
         */
        className: 'Phorum.UI.Element',

        /**
         * @property isElement
         *
         * This property can be used as an easy way to check if an object
         * is based on this class. JavaScript's instanceof does not support
         * checking object inheritance.
         *
         * @var {String}
         */
        isElement: true,

        /**
         * @property selectors
         *
         * The array of jQuery selectors to search for.
         * Derived classes can override this property to set the default
         * list of selectors to check.
         *
         * @var Array
         * @private
         */
        selectors: [ ],

        /**
         * @property object
         *
         * A reference to the managed DOM element.
         *
         * @var Object
         * @private
         */
        object: null,

        /**
         * @property $object
         *
         * A reference to the jQuery wrapper object for the managed DOM element.
         *
         * @var jQuery
         */
        $object: null,

        /**
         * A shortcut alias for the {@link #$object $object} property.
         * It contains the jQuery wrapper for the managed element.
         *
         * @return {jQuery} $object
         */
        $: null,

        /**
         * Can be used to check if the constructor found an element to manage.
         *
         * @return {Boolean} found
         *     True in case an element was found, false otherwise.
         */
        found: function () {
            return this.$object ? true : false;
        },

        /**
         * Move the focus to the element.
         */
        focus: function ()
        {
            this.$object.focus();
        },

        /**
         * For form field elements, retrieve or set the form field value.
         * When retrieving a value, whitespace is trimmed from it.
         *
         * @param {mixed} value (optional)
         *   The value to set. Omit this parameter to retrieve the
         *   field value.
         *
         * @return {String} value
         *   The trimmed form field value.
         */
        value: function (value)
        {
            if (value !== undefined) {
                this.$object.val(value);
            }

            value = this.$object.val();
            if (value === null || value === undefined) {
                value = '';
            } else {
                value = Phorum.trim(value);
            }

            return value;
        }
    }
);

/**
 * @class Phorum.UI.TextElement
 * @extends Phorum.UI.Element
 *
 * <p>
 *   This class can be used to access and manipulate text input fields
 *   (textarea, input type="text"). This class mainly serves as a
 *   base class.
 * </p>
 * @constructor
 *   Create a new Phorum.UI.TextElement object.
 * @param {String/Array} selectors (optional)
 *   The jQuery selector or selectors to use for looking up the element to
 *   manage. The first selector that matches a single element will be used.
 *   When no selectors are provided, then the selectors from the
 *   {@link #selectors selectors} configuration property will be used instead.
 */
Phorum.UI.TextElement = Phorum.extend(Phorum.UI.Element,

    // Constructor ==========================================================

    function (selectors) {

        this.className = 'Phorum.UI.TextElement';
        this.parentConstructor(selectors);
    },

    // Prototype ============================================================

    {
        /**
         * @property isTextElement
         *
         * This property can be used as an easy way to check if an object
         * is based on this class. JavaScript's instanceof does not support
         * checking object inheritance.
         *
         * @var {String}
         */
        isTextElement: true,

        /**
         * Add tags (e.g. BBcode tags) to the text element.
         * <p>
         *   If some text is selected, then place the tags around the
         *   selected text. If no text is selected and a prompt_str is
         *   provided, then prompt the user for the data to place inside
         *   the tags.
         * </p>
         * <p><pre><code>
var elt = new Phorum.UI.TextElement();
elt.addTags('[b]', '[/b]');
elt.addTags('[url]', '[/url]', 'Please, enter the URL');
         * </code></pre></p>
         *
         * @param {String} pre
         *   The tag to put in front of the selection or manual input.
         * @param {String} post
         *   The tag to put after the selection or manual input.
         */
        addTags: function (pre, post, prompt_str)
        {
            var text;
            var pretext;
            var posttext;
            var range;
            var res;

            if (pre === undefined || pre === null) {
                pre = '';
            }
            if (post === undefined || post === null) {
                post = '';
            }

            // Store the current scroll offset, so we can restore it after
            // adding the tags to its contents.
            var offset = this.object.scrollTop;

            if (this.object.setSelectionRange)
            {
                // Get the currently selected text.
                pretext = this.object.value.substring(
                    0, this.object.selectionStart);
                text = this.object.value.substring(
                    this.object.selectionStart, this.object.selectionEnd);
                posttext = this.object.value.substring(
                    this.object.selectionEnd, this.object.value.length);

                // Prompt for input if no text was selected and a prompt is set.
                if (text === '' && prompt_str) {
                    text = prompt(prompt_str, '');
                    if (text === null) {
                        return;
                    }
                }

                // Strip whitespace from text selection and move it to the
                // pre- and post.
                res = Phorum.trim(text, true);
                text = res[0];
                pre = res[1] + pre;
                post = post + res[2];

                this.object.value = pretext + pre + text + post + posttext;

                // Reselect the selected text.
                var cursorpos1 = pretext.length + pre.length;
                var cursorpos2 = cursorpos1 + text.length;
                this.object.setSelectionRange(cursorpos1, cursorpos2);
                this.object.focus();
            }
            else if (document.selection) /* MSIE support */
            {
                // Get the currently selected text.
                this.focus();
                range = document.selection.createRange();

                // Fumbling to work around newline selections at the end of
                // the text selection. MSIE does not include them in the
                // range.text, but it does replace them when setting range.text
                // to a new value :-/
                var virtlen = range.text.length;
                if (virtlen > 0) {
                    while (range.text.length === virtlen) {
                        range.moveEnd('character', -1);
                    }
                    range.moveEnd('character', +1);
                }

                // Prompt for input if no text was selected and a prompt is set.
                text = range.text;
                if (text === '' && prompt_str) {
                    text = prompt(prompt_str, '');
                    if (text === null) {
                        return;
                    }
                }

                // Strip whitespace from text selection and move it to the
                // pre- and post.
                res = Phorum.trim(text, true);
                text = res[0];
                pre = res[1] + pre;
                post = post + res[2];

                // Add pre and post to the text.
                range.text = pre + text + post;

                // Reselect the selected text. Another MSIE anomaly has to be
                // taken care of here. MSIE will include carriage returns
                // in the text.length, but it does not take them into account
                // when using selection range moving methods :-/
                // By setting the range.text before, the cursor is now after
                // the replaced code, so we will move the start and the end
                // back in the text.
                var mvstart = post.length + text.length -
                              ((text + post).split('\r').length - 1);
                var mvend   = post.length +
                              (post.split('\r').length - 1);
                range.moveStart('character', -mvstart);
                range.moveEnd('character', -mvend);
                range.select();
            }
            else /* Support for really limited browsers, e.g. MSIE5 on MacOS */
            {
                this.object.value = this.object.value + pre + post;
            }

            this.object.scrollTop = offset;
        },

        /**
         * Used to store the tex element's selection range.
         *
         * @private
         */
        selectionRange: null,

        /**
         * <p>
         *   Store the active selection range of the text element.
         *   This can be used to restore the selection range at a later time
         *   using {@link #restoreSelection restoreSelection()}.
         * </p>
         * <p>
         *   Currently, this will only act for MSIE. It was implemented because
         *   MSIE sometimes clears the selection range in the text element when
         *   clicking in a popup window.
         * </p>
         */
        storeSelection: function ()
        {
            // This rules out non-MSIE browsers, which do not need to store
            // the selecton range.
            if (this.object.setSelectionRange || ! document.selection) {
                return;
            }

            this.object.focus();
            this.selectionRange = document.selection.createRange();
        },

        /**
         * <p>
         *   Restore a textarea selection range that was previously stored
         *   using {@link #restoreSelection storeSelection()}.
         * </p>
         */
        restoreSelection: function ()
        {
            if (this.selectionRange !== null) {
                this.selectionRange.select();
                this.selectionRange = null;
            }
        }
    }
);

/**
 * @class Phorum.UI.Editor
 * @extends Phorum.UI.Element
 *
 * <p>
 *   This class can be used to access and manipulate the
 *   posting editor in Phorum.
 * </p>
 * <p>
 *   By default, the constructor will automatically search the page for a
 *   div element with id "post". If you need more control over the selector(s)
 *   to use for the editor lookup, then you can provide a jQuery selector or
 *   selector array as the argument for the constructor.
 * </p>
 * <p><pre><code>
// Retrieve the editor using the built-in selector.
var e1 = new Phorum.UI.Editor();
e1.getBody().focus();

// Retrieve the editor using a custom jQuery selector.
var e2 = new Phorum.UI.Editor('#phorum #myeditor');
t2.getSubject().addTags(':-)');

// It is possible to access the jQuery wrapper object for the editor.
t2.$object.hide();
// Or even shorter.
t2.$.hide();
 * </code></pre></p>
 *
 * @constructor
 *   Create a new Phorum.UI.Editor object.
 * @param {String/Array} selectors (optional)
 *   The jQuery selector or selectors to use for looking up the editor element.
 *   The first selector that matches a single element will be used.
 *   When no selectors are provided, then the built-in selector will be
 *   used by default.
 */
Phorum.UI.Editor = Phorum.extend(Phorum.UI.Element,

    // Constructor ==========================================================

    function (selectors) {

        this.className = 'Phorum.UI.Editor';

        this.selectors = [
            'div.PDDiv #phorum-post-form', // classic template
            '#phorum #post'   // Phorum 5.2+, no need to support older versions
        ];

        this.parentConstructor(selectors);

        /**
         * @property subject
         *
         * A reference to the subject element in the editor.
         *
         * @var Phorum.UI.TextElement
         */
        this.subject = this.getField('subject');

        /**
         * @property body
         *
         * A reference to the body element in the editor.
         *
         * @var Phorum.UI.TextElement
         */
        this.body = this.getField('body');
    },

    // Prototype ============================================================

    {
        /**
         * Used by the focus() method to automatically find a field to focus.
         *
         * @private
         */
        focusFields: [
            'author',
            'subject',
            'body'
        ],

        /**
         * Focus the editor. By default, this method will move the focus in the
         * editor to the first logical input field. By providing a field name
         * as the argument, the exact field to focus can be controlled.
         *
         * @param {String} field_name (optional)
         *   The name of the form field to focus. If not provided, then
         *   Phorm.UI.Editor will automatically pick a logical field to focus.
         */
        focus: function (field_name)
        {
            // No field provided? Move the focus to the author, subject or
            // message body field. The first existing and empty field gets
            // the focus. If none of the fields is empty, then the body
            // is focused by default.
            if (field_name === undefined)
            {
                field_name = 'body';
                for (var i = 0; i < this.focusFields.length; i++)
                {
                    // Retrieve the field from the editor.
                    field_name = this.focusFields[i];
                    var f = this.getField(this.focusFields[i]);

                    // If this field is empty, then use this one for focusing.
                    var value = f.$.val();
                    value = Phorum.trim(value);
                    if (value === '') {
                        break;
                    }
                }
            }

            this.getField(field_name).$.focus();
        },

        /**
         * A cache that holds the Phorum.UI.Element objects that were
         * retrieved using getField().
         *
         * @private
         */
        fields: { },

        /**
         * Retrieve the Phorum.UI.Element wrapper for a form field within
         * this editor.
         *
         * @param {String} field_name
         *   The name of the form field to retrieve.
         * @return {Phorum.UI.Element} field
         *   The Phorum.UI.Element object for the form field if exactly one
         *   element was found.
         */
        getField: function (field_name)
        {
            // Check the lookup cache.
            if (this.fields[field_name] === undefined)
            {
                // Look up the field by its name.
                var selector = '*[name=' + field_name + ']';
                var $fields = this.$object.find(selector);

                // If we found one or more fields, then create a
                // Phorum.UI.Element wrapper. When more than one field is found,
                // then the last one is used. This is to accommodate for the
                // fact that we add all fields as hidden fields to the editor
                // form and that we add normal form fields to override the
                // hidden fields.
                if ($fields.length > 0)
                {
                    var field;
                    var $f = $fields.last();

                    // For text input fields, we use a different base class,
                    // which allows us to do text manipulations on the data.
                    if ($f.is('textarea') ||
                        ($f.is('input') && $f.attr('type') === 'text')) {
                        field = new Phorum.UI.TextElement($f);
                    }
                    else {
                        field = new Phorum.UI.Element($f);
                    }

                    this.fields[field_name] = field;
                }
                // If no fieldwas found, then we don't accept the result.
                // We always expect there to be exactly one matching field.
                else {
                    throw this.className + '.getField(): no matching form ' +
                    'field found for name=' + field_name;
                }
            }

            return this.fields[field_name];
        }
    }
);

// Add base CSS code for Phorum.UI.BusyMarker the page. It is inserted
// at the beginning of the head section, so template CSS code can be
// used to override the basic style.
$PJ(document).ready(function () {
    $PJ('<style type="text/css">' +
        '.phorum_busy_marker ' +
        '{' +
            'position: fixed; ' +
            'top: 0; ' +
            'left: 0; ' +
            'border: 1px solid #aa5; ' +
            'background: #ff9; ' +
            'padding: 0.2em 1em; ' +
            'z-index: 1000; ' +
        '}' +
        '</style>').prependTo($PJ('head'));
});

/**
 * @class Phorum.UI.BusyMarker
 * <p>
 *   The Phorum.UI.BusyMarker singleton implements a busy marker for the
 *   Phorum UI. This marker is used for notifying the user about running async
 *   calls to the server (or other async activities).
 * </p>
 * <p>
 *   The default implementation will show a message box at a fixed position
 *   in the top left of the page, notifying the user about the number of
 *   pending actions. This box can be styled by CSS through the
 *   phorum_busy_marker class. For example:
 * </p>
 * <p><pre><code>
#phorum .phorum_busy_marker {
    border: 1px solid black;
    background: #ddd;
    color: white;
}
 * </code></pre></p>
 * <p>
 *   The template author can even go a step further than changing the CSS
 *   styling alone by fully overriding the Phorum.UI.BusyMarker.render()
 *   method through the template javascript code. This method can check the
 *   {@link #count Phorum.UI.BusyMarker.count} property to find out how many
 *   busy tasks there are and render a custom busy marker accordingly.
 * </p>
 *
 * @singleton
 */
Phorum.UI.BusyMarker =
{
    /**
     * @property className
     * @private
     */
    className: 'Phorum.UI.BusyMarker',

    // The public interface of the busy marker ==============================

    /**
     * @property count
     *
     * The number of pending actions. This property is updated by the
     * {@link #increment increment()} and {@link #decrement decrement()}
     * methods.
     *
     * @var Integer
     */
    count : 0,

    /**
     * Increment the number of pending actions, e.g. when starting
     * an Ajax call. After incrementing the counter, the busy marker
     * will automatically render.
     */
    increment: function ()
    {
        this.count ++;
        Phorum.debug(
            this.className + ': counter incremented to: ' + this.count, 10);

        this.render();
    },

    /**
     * Decrement the number of pending actions, e.g. when an Ajax reply
     * is received. After decrementing the counter, the busy marker is
     * automatically updated or cleaned up when the counter reached zero.
     */
    decrement: function ()
    {
        this.count --;
        Phorum.debug(
            this.className + ': Busy marker counter decremented to: ' +
            this.count, 10);

        if (this.count < 0) {
            throw 'Yoda.UI.BusyMarker: the busy counter went below zero! ' +
                  'The decrement() method was called more often than the ' +
                  'decrement() method. This should not happen.';
        }
        this.render();
    },

    // Specific code for rendering the default busy marker ==================

    // The following code can be overridden by template
    // JavaScript code to implement a different marker.

     /**
      * @property $box
      *
      * Used to store our $box jQuery object
      *
      * @var Object
      * @private
      */
    $box: null,

    /**
     * <p>
     *   Render the busy marker or clean up the existing busy marker when the
     *   busy {@link #count counter} has reached zero.
     * </p>
     * <p>
     *   This method is automatically called from the
     *   {@link #increment increment()} and {@link #decrement decrement()}
     *   methods, so there should be no need to actively call it yourself.
     * </p>
     * <p>
     *   When a different busy marker is required for a template, then this
     *   method (Phorum.UI.BusyMarker.render()) can be overriden from the
     *   template's JavaScript code to alter the rendering to whatever is
     *   appropriate for the template.
     * </p>
     */
    render: function ()
    {
        // If no actions are pending, clear up the busy message after a
        // little 100ms pause (to keep the busy message from being
        // irritatingly flashy on screen).
        if (this.count === 0) {
            Phorum.debug(this.className + ': delete the busy marker', 10);
            Phorum.UI.BusyMarker.$box.
              stop(true, false).show().delay(100).fadeOut(1000);
            return;
        }

        // Create the notify box if it is not available yet.
        if (this.$box === null)
        {
            Phorum.debug(this.className + ': render the busy marker', 10);

            // Create the box.
            this.$box = $PJ('<div class="phorum_busy_marker"/>');

            // Add the box to the page. We add it to the #phorum wrapper and
            // not to the page body to make it inherit CSS styles from #phorum.
            $PJ('#phorum').prepend(this.$box);
        }

        // <?php $lang = $PHORUM['DATA']['LANG']; ?>

        // Determine the message to show.
        var message =
            this.count === 1 ?
            '<?php print addslashes($lang["ActionPending"]) ?>' :
            '<?php print addslashes($lang["ActionsPending"]) ?>';

        // Replace %count% in the message with the current action count.
        Phorum.debug(
            this.className + ': set busy marker message: ' + message, 10);
        message = message.replace(/%count%/, this.count);

        // Show the busy marker.
        Phorum.debug(this.className + ': show the busy marker', 10);
        this.$box.html(message);
        this.$box.stop(true, false).css('opacity', 1).show();
    }
};

/**
 * @class Phorum.UI.NewFlags
 * @extends Object
 *
 * <p>
 *   The Phorum.UI.NewFlags singleton implements a framework for handling
 *   newflags in Phorum. It provides features to to handle "mark read" actions
 *   through Ajax communication to the server and to update the user interface
 *   after a "mark read" Ajax call has completed successfully.
 * </p>
 * <p>
 *   For templates to support handling mark new actions through Ajax, they have
 *   to include calls to {@link #markRead Phorum.UI.NewFlags.markRead()} or
 *   the shorter alias {@link Phorum#markRead Phorum.markRead()}.
 * </p>
 * <p>
 *   For updating the user interface after a successful call, a few built-in
 *   actions are provided. See {@link #updateUI updateUI()} for a description
 *   of these. If a template or module author needs support for a type of
 *   action that is not built-in, extra actions can be implemented by
 *   registering a callback through
 *   {@link #registerActionCallback registerActionCallback()}.
 * </p>
 *
 * @singleton
 */
Phorum.UI.NewFlags = {

    /**
     * @property className
     * @private
     */
    className: 'Phorum.UI.NewFlags',

    /**
     * <p>
     *   This is the callback registry. It holds global and action based
     *   callback functions that will be called when a
     *   {@link #markRead Phorum.UI.NewFlags.markRead()} call has been
     *   executed successfully.
     * </p>
     *
     * @private
     */
    callbacks: {
        global: [ ],
        action: { }
    },

    /**
     * <p>
     *   Register a global callback function that has to be called after every
     *   {@link #markRead markRead()} call has been completed successfully.
     * </p>
     * <p>
     *   The registered global callback functions will be called with two
     *   parameters, which identify what messages have been marked read:
     *   <div class="mdetail-params"><ul>
     *     <li><b>mode</b>: "vroots", "forums", "threads" or "messages"</li>
     *     <li><b>item_id</b>: the forum, thread or message id</li>
     *   </ul></div>
     * </p>
     * <p>
     *   <b>Example code:</b>
     * </p>
     * <p><pre><code>
Phorum.UI.NewFlags.registerCallback(function (mode, item_id) {
  alert("Mark read was successful for " + mode + ", id " + item_id);
});
     * </code></pre></p>
     *
     * @param {Function} callback
     *   The callback function to register.
     *
     * @param {Object} scope (optional)
     *   The scope to use for the callback.
     */
    registerCallback: function (callback, scope)
    {
        if (!(callback instanceof Function)) {
            throw this.className + '.registerCallback(): ' +
                  'the callback must be a function';
        }

        this.callbacks.global.push([callback, scope]);
    },

    /**
     * <p>
     *   Register a callback function for a specific action that has to be
     *   called after a {@link #markRead markRead()} call has been completed
     *   successfully.
     * </p>
     * <p>
     *   The registered action callback functions will be called with two
     *   parameters, which both identify the matching element:
     *   <div class="mdetail-params"><ul>
     *     <li><b>element</b>: the matching DOM-element</li>
     *     <li><b>$element</b>: the jQuery wrapper for the DOM-element</li>
     *   </ul></div>
     * </p>
     * <p>
     *   <b>Example code:</b>
     * </p>
     * <p><pre><code>
In javascript:

function handleCustomAction(elt, $elt) {
    $elt.css('color', 'green');
}

Phorum.UI.NewFlags.registerActionCallback('custom', handleCustomAction);

In template:

<span class="new-flag[custom,10,5,293]">
  this text will turn green when the message is read
</span>
     * </code></pre></p>
     *
     * @param {String} action (optional)
     *   The action for which to register the callback. The action is defined
     *   in the special new-flag[&lt;action&gt;,...] CSS class (see
     *   {@link #updateUI updateUI()} for more info).
     *
     * @param {Function} callback
     *   The callback function to register.
     *
     * @param {Object} scope (optional)
     *   The scope to use for the callback.
     */
    registerActionCallback: function (action, callback, scope)
    {
        if (!(callback instanceof Function)) {
            throw this.className + '.registerActionCallback(): ' +
                  'the callback must be a function';
        }
        if (this.callbacks.action[action] === undefined) {
            this.callbacks.action[action] = [ ];
        }
        this.callbacks.action[action].push([callback, scope]);
    },

    /**
     * <p>
     *   This method can be called from "mark read" links to handle marking
     *   vroots, forums, threads or messages read through Ajax calls. After the
     *   call has finished successfully, {@link #updateUI updateUI} will be
     *   called to update the user interface.
     * </p>
     * <p>
     *   This method is also available through the alias
     *   {@link Phorum#markRead Phorum.markRead()}.
     * </p>
     * <p>
     *   <b>Example code</b>
     * </p>
     * <p><pre><code>
&lt;a href="http://example.com/index.php?10,markread,0"
   onclick="return Phorum.UI.NewFlags.markRead('forums', 10)"&gt;
    Mark forum read
&lt;/a&gt;
     * </code></pre></p>
     *
     * @param {String} mode
     *     One of "vroots", "forums", "threads" or "messages".
     *
     * @param {Integer} item_id
     *     A vroot, forum, thread or message id (which one to use depends
     *     on the "mode" parameter).
     *
     * @param {Function} callback (optional)
     *     A callback function to call when the operation has been completed.
     *     This function will get true (mark read successful) or false
     *     (mark read failed) as its argument.
     *
     * @param {Object} scope (optional)
     *     The scope to use for the callback.
     *
     * @return boolean false
     *     This method always returns false, which makes it simple to cancel
     *     events (e.g. onclick="return Phorum.UI.NewFlags.markRead(...)")
     */
    markRead: function (mode, item_id, callback, scope)
    {
        // Request busy notification for the user.
        Phorum.UI.BusyMarker.increment();

        var request = {
            'call': 'markread',
            'onSuccess': function (data) {
                Phorum.UI.BusyMarker.decrement();
                Phorum.UI.NewFlags.updateUI(mode, item_id);
                if (callback instanceof Function) {
                    callback.call(scope || this, true);
                }
            },
            'onFailure': function (data) {
                Phorum.UI.BusyMarker.decrement();
                if (callback instanceof Function) {
                    callback.call(scope || this, false);
                }
            }
        };

        // Because the "mode" is dynamic ("vroots", "forums", "threads"
        // or "messages"), we have to assign this property of the request
        // like this.
        request[mode] = [ item_id ];

        Phorum.debug(
            this.className + ': call markread for mode = ' + mode + ', ' +
            'id = ' + item_id, 5
        );

        // Dispatch the Ajax Phorum call.
        Phorum.call(request);

        // So "return Phorum.UI.NewFlags.markRead(...)" can be used to cancel
        // an <a href> click.
        return false;
    },

    /**
     * <p>
     *   Update the user interface after marking messages as read.
     * </p>
     * <p>
     *   This method implements a few built-in actions for updating the
     *   user interface. If a template or module needs custom handling of
     *   mark read events, then the {@link #registerCallback registerCallback()}
     *   and {@link #registerActionCallback registerActionCallback()} methods
     *   can be used to implement custom functions.
     * </p>
     * <p>
     *   <b>Built-in UI update actions:</b>
     * </p>
     * <p>
     *   Below, we will describe the built-in actions that are provided by
     *   Phorum.UI.NewFlags. Linking one of these actions to a page element
     *   is done by assigning a CSS class that looks like:
     *   <pre><code>
new-flag[&lt;action&gt;,&lt;item&gt;]
     *   </code></pre>
     * </p>
     *   The &lt;item&gt; part in here references the item to which the new
     *   flag is linked. The format is:
     *   <pre><code>
&lt;forum id&gt;[, &lt;thread id&gt;[, &lt;message id&gt;]]

&lt &gt = mandatory
[ ] = optional

Examples:
10      = forum 10, for example on the index, where forums are listed
10,5    = forum 10, thread 5, for example on the list, where threads are listed
10,5,84 = forum 10, thread 5, message 85, for example on the read page
     *   </code></pre>
     * Using this notation, a mark read event for thread id 5 would match both
     * "10,5" and "10,5,84".
     * </p>
     * <p>
     *   The &lt;action&gt; part references the action that must be performed
     *   on the element. Below here, the built-in actions are described.
     * </p>
     * <div class="mdetail-params"><ul>
     *   <li>
     *     <b>Action: hide</b>:<br/>
     *     An element that will be hidden when the related item is
     *     marked read.<br/>
     *     In the default Phorum template, this is used for the
     *     red "new" text that is shown for new messages.<br/>
     *     <br/>
     *     Template code:
     *     <pre><code>
&lt;<i>element</i> class="new-flag[hide,&lt;item&gt;]"&gt;
  ... code to hide when marked read ...
&lt;/<i>element</i>&gt;

For example:

&lt;span class="new-flag[hide,10,5,84] new-flag"&gt;new&lt;/span&gt;
     *     </code></pre>
     *   </li>
     *   <li>
     *     <b>Action: css</b>:<br/>
     *     An element, from which the CSS class "new-flag" will be removed and
     *     to which the CSS class "read-flag" will be added when the related
     *     item is marked read.<br/>
     *     In the default Phorum template, this is for example used for the
     *     styling of the subject for new or updated threads on the list page.
     *     New subjects are displayed in a bold font.<br/>
     *     <br/>
     *     Template code:
     *     <pre><code>
&lt;<i>element</i> class="new-flag[css,&lt;item&gt;] new-flag"&gt;
   ... code to style ...
&lt;/<i>element</i>&gt;

For example:

&lt;a href="http://example.com/read.php?10,5,84#msg-84"
   class="new-flag[css,10,5] new-flag"&gt;Phorum rocks!&lt;/a&gt;
     *     </code></pre>
     *   </li>
     * </ul></div>
     *
     * @param {String} mode
     *     One of "vroots", "forums", "threads" or "messages".
     *
     * @param {Array} item_id
     *     The vroot, forum, thread or message id (which one to use depends
     *     on the "mode" parameter).
     */
    updateUI: function (mode, item_id)
    {
        var func = this.className + '.updateUI()';

        Phorum.debug(
            func + ': update UI for mode = ' + mode + ', ' +
            'id = ' + item_id, 5
        );

        // Build the regular expression for matching elements that have a
        // new flag action linked to them.
        var regexp = '^new-flag\\[(\\w+),';
        switch (mode) {
        case "vroots":
            regexp += '(\\d+)?(,\\d+){0,2}';
            break;
        case "forums":
            regexp += item_id + '(,\\d+){0,2}';
            break;
        case "threads":
            regexp += '\\d+,' + item_id + '(,\\d+)?';
            break;
        case "messages":
            regexp += '\\d+,\\d+,' + item_id;
            break;
        default:
            throw func + ': ' +
                  'processMatchingTags(): illegal mode: ' + mode;
        }
        regexp += '\\]';
        var re = new RegExp();
        re.compile(regexp);

        Phorum.debug(
            func + ': find elements that have a CSS class ' +
            'matching: ' + regexp, 10
        );

        // Find all elements that have "new-flag[" somewhere in the class name.
        // These are candidates for matching the complete
        // "new-flag[<action>,<item>]" class format.
        var me = this;
        $PJ("*[class*='new-flag[']").each(function ()
        {
            var $element = $PJ(this);
            var classes = $element.attr('class').split(' ');

            Phorum.debug(
                func + ': inspect element classes: ' + classes.join(', '), 10
            );

            // Elements might have more than one class name assigned to them.
            // Inspect each class name separately.
            for (var i = 0; i < classes.length; i++)
            {
                var match = re.exec(classes[i]);
                if (match)
                {
                    var action = match[1];

                    // Handle built-in action.
                    switch (action) {

                    case 'hide':
                        $element.fadeOut();
                        break;

                    case 'css':
                        $element.addClass('read-flag');
                        $element.removeClass('new-flag');
                        break;

                    }

                    // Handle action callback.
                    if (me.callbacks.action[action] !== undefined) {
                        var callbacks = me.callbacks.action[action];
                        for (var j = 0; j < callbacks.length; j++) {
                            var callback = callbacks[j][0];
                            var scope    = callbacks[j][1];
                            callback.call(scope || this, this, $element);
                        }
                    }
                }
            }
        });

        // Call all registered global callback functions
        // to handle custom mark read functionality.
        for (var i = 0; i < this.callbacks.global.length; i++) {
            var callback = this.callbacks[i][0];
            var scope    = this.callbacks[i][1];
            callback.call(scope || this, mode, item_id);
        }
    }
};

/**
 * An alias for
 * {@link Phorum.UI.NewFlags#markRead Phorum.UI.NewFlags.markRead()}.
 * See the documentation of that method for more information.
 *
 * @param {String} mode
 * @param {Integer/Array} item_id
 * @method Phorum.markRead
 * @member Phorum markRead
 */
Phorum.markRead = Phorum.UI.NewFlags.markRead;

/**
 * An alias for
 * {@link Phorum.Ajax#call Phorum.Ajax.call()}.
 * See the documentation of that method for more information.
 *
 * @param {Object} req
 * @method Phorum.call
 * @member Phorum call
 */
Phorum.call = Phorum.Ajax.call;

